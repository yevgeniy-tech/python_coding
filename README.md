# Scientific Python. Цой Евгений
# Project #3. Sequential Gaussian Simulation
**Предисловие**

Проект был выполнен на языке программирования Python 3 с использованием веб-оболочки Jupyter Notebook согласно основному требованию – реализация посредством объектно-ориентированного программирования (ООП).
Следует отметить, что данная работа «Sequential Gaussian Simulation» является своего рода продолжением (или можно сказать расширением) работы, которую я выполнял прежде – «Simple Kriging», и именно этот фактор стал одной из ключевых причин выбора данного проекта (потому что захотелось копнуть глубже и посмотреть как всё устроено).
И так, начну интерпретировать ход работы и её суть (задействованные методы, анализ данных и т. д.) по порядку step by step, чтобы ничего не упустить и создать целостность картины.
***
**Для чего мы вообще производим вычисления в этой работе?**

Вкратце, имеются координаты некоторых точек с известными значениями, но также имеется одна точка с известным местоположением, но неизвестным значением. Так вот мы хотим найти (смоделировать) это значение по уже известным данным, для этого и делаются вычисления. При этом ближе к концу работы мы должны получить оценку и дисперсию Кригинга, и вроде бы, это напоминает работу «Simple Kriging», но не тут-то было. В «Simple Kriging» оценка и дисперсия Кригинга являются итоговыми получаемыми величинами, тут же они выступают в качестве промежуточного звена, необходимого для вычисления финального множества равновероятных реализаций.
***
**Почему работа называется «Sequential Gaussian Simulation»?**

Потому что в основе этого проекта лежит метод последовательного гауссова моделирования – стохастический метод, основанный на кригинге. Он широко используется в первую очередь в геостатистике.
***
**Что мы должны иметь (какие данные), чтобы успешно применять SGS?**

В данной работе следующая Input Data:

![screenshot of sample](https://i.ibb.co/WF3D6Xw/input-data.png)

0.Representative Distribution and Transform
То есть, во-первых, и самое главное – я должен задать ключевые параметры распределения, а именно математическое ожидание и стандартную ошибку.

1.Data
Ввожу координаты трёх опорных точек и их значения, также ввожу координаты точки unknown (value которой неизвестно).

3.Variogram Model
И, конечно же, определяю параметры модели вариограммы: Nugget effect (вертикальное расстояние между 0 и точкой, где модель вариограммы пересекает ось ординат), Variogram type (в данном случае, сферическая) и Range (диапазон).
***
**Какие требования предъявляются к данным при применении SGS?**

Да, возможно в нашем случае этим пунктом можно было бы и пренебречь, так как SGS применим к имеющимся входным данным и работать этот метод будет исправно. Но я решил вникнуть, если вдруг я буду применять SGS по отношению к реальным данным, например, для моделирования значений пористости (ведь, насколько я разобрался, чаще всего SGS используется именно для этого), то какими эти данные должны быть или какой pre-processing мне нужно будет провести. Как оказалось, требования к данным следующие:
* Стационарность. То есть поведение данных не должно зависеть от их расположения. Если же нестационарность всё-таки наблюдается, то в таком случае области с различными статистическими характеристиками должны изучаться и моделироваться раздельно.
* Отсутствие тренда. Но, как мы знаем, тренд у данных присутствует довольно часто. В этом случае трендовая компонента выделяется и исключается из данных, но по окончании моделирования добавляется обратно.
* Стандартное нормальное распределение. Пожалуй, самое интересное и наблюдаемое требование, в этой работе так уж точно. Понятное дело, что на практике реальные данные (например, геологические) не всегда являются нормально распределенными, поэтому тут нужен pre-processing. Он заключается в преобразовании исходных данных к нормальному распределению (и соответственно получении гладкой кривой CDF).
***
**Pre-processing**

Непосредственно в работе я указываю параметры распределения (mean и standard deviation), а также задаю P-values и на основании этого генерирую Data. Но теперь, как я уже сказал выше, мне необходимо преобразовать эти данные к нормальному распределению, а точнее стандартному нормальному распределению, у которого, как нам известно, среднее = 0, а стандартное отклонение = 1. Для этого я использую scipy.stats.norm.ppf (percent point function является обратной функцией для CDF). Таким образом, у меня имеются Data и Standard Normal.
***
**Визуализация**

Теперь я располагаю всем необходимым для построения трёх графиков, фигурирующих в работе.
График 1. Представляет собой условную кумулятивную функцию распределения (CCDF), базирующуюся на Data и Standard Normal (относительно P-values).

![screenshot of sample](https://i.ibb.co/fdxxXtj/figure-1.png) 

График 2. Q-Q (Quantile-Quantile) Plot. Этот график используется для сравнения двух распределений вероятностей путём построения их квантилей.

![screenshot of sample](https://i.ibb.co/LZNg9gj/figure-2.png) 

У меня получилась прямая линия, что указывает на наличие, если так можно выразиться, "совершенного" или "идеального" нормального распределения. 

График 3. Наглядно отображает координаты точек и их расположение относительно друг друга

![screenshot of sample](https://i.ibb.co/WtGQ6gG/figure-3.png) 
***
**Алгоритм**

Вычисление Gaussian и mean для значений по трём точкам.

![screenshot of sample](https://i.ibb.co/CsWJzhQ/1.png) 

Вычисление матрицы расстояний «Distance Matrix»

![screenshot of sample](https://i.ibb.co/2y5YRJ2/2.png) 

Вычисление «Variogram Matrix»

![screenshot of sample](https://i.ibb.co/Fnz9rwF/4.png) 

Вычисление матрицы ковариации «Covariance Matrix»

![screenshot of sample](https://i.ibb.co/Vp78wk6/5.png) 

Вычисление обратной матрицы для левой части ковариационной матрицы «Inverse Left Side»

![screenshot of sample](https://i.ibb.co/m9QPY5s/6.png) 

Вычисление весов Simple Kriging «Weights»

![screenshot of sample](https://i.ibb.co/dWGLQnf/7.png) 

Вычисление оценки и дисперсии Кригинга «Kriging Results»

![screenshot of sample](https://i.ibb.co/fNkjrKw/8.png) 

Вычисление реализаций «Simulation Results»

![screenshot of sample](https://i.ibb.co/zmLzwYh/9.png) 
***
**Результат**

Получив значения оценки и дисперсии (которая показывает относительную меру достоверности оценки) Кригинга для искомой точки я применяю их для моделирования финального множества равновероятных реализаций (Realization – Simulation).

Примечание – эти реализации могут быть смоделированы с одинаковым набором входных данных, но при этом меняя случайный порядок обхода моделируемых неизвестных значений. То есть множество равновероятных реализаций обусловлено случайной траекторией, это ещё раз доказывает, что SGS является стохастическим методом.

Затем следует очень важный момент – необходимо преобразовать смоделированные значения «Simulation» обратно к исходному распределению данных «Back Transformed» (достигается это использованием кривой CDF). 
***
**Выводы, полученные экспериментальным путём**

1) Последовательное гауссово моделирование зависит от входных данных и при этом сохраняет их распределение.
2) При увеличении диапазона вариограммы уменьшается дисперсия local CDF.
3) При увеличении Nugget effect увеличивается дисперсия local CDF.
4) Сферическая и экспоненциальная модели дают похожие результаты. Гауссова модель даёт сглаженный результат.
***
**Заключение**

Таким образом, в данном проекте «Sequential Gaussian Simulation» была воссоздана работа из Excel – написана на Python с применением объектно-ориентированного программирования. Было детально разобрано последовательное гауссово моделирование, включая принцип его работы и особенности применения. В процессе выполнения проекта были приобретены как навыки программирования на Python, в особенности ООП, так и знания касающиеся моделирования и статистики.
